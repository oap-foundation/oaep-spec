# Open Agent Exchange Protocol (OAEP) Specification - Draft v0.1

**Important Note:** This document is a **v0.1 Draft**. It serves as a technical "Strawman Proposal" to initiate discussion with the first developers and founding partners. The final specification will emerge from an iterative process of prototyping, feedback, and consensus-building within the future Working Groups of the OAP Foundation.

## 1. General Principles & Architecture

*   **Architecture:** Layered Model. The Open Agent Exchange Protocol (OAEP) is Layer 0, the mandatory foundation for all Layer 1 application protocols.
*   **Data Format:** All payloads are encoded in **JSON-LD (JSON for Linked Data)** to ensure semantic interoperability and machine-readable understanding.
*   **Security:** All communication **MUST** be secured via **TLS 1.3 or higher**. All sensitive data is end-to-end encrypted on the client side.
*   **Identity:** The entire system is built upon the W3C standards of **Decentralized Identifiers (DIDs)** and **Verifiable Credentials (VCs)**.

## 2. The Base Protocol: Open Agent Exchange Protocol (OAEP) v1.0

**Purpose:** To establish a secure, mutually authenticated, and trustworthy communication relationship between two or more agents.

### 2.1 Core Objects

The central object in OAEP is the `AgentProfile`. It is the digital business card of every participant in the ecosystem and is implemented as a W3C Verifiable Credential (VC).

*   **`AgentProfile` (Verifiable Credential):** A VC that describes the identity and foundational capabilities of an agent.

**Example of an `AgentProfile` Structure in JSON-LD:**
```json
{
  // The context defines the vocabulary (W3C Standard + OAEP Extension)
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://openagentprotocol.org/contexts/oaep/v1"
  ],

  // Unique ID of the credential itself
  "id": "urn:uuid:12345678-1234-5678-1234-567812345678",

  // Type definition: It is a Verifiable Credential and an AgentProfile
  "type": ["VerifiableCredential", "AgentProfile"],

  // The issuer of the credential (e.g., a bank, an eID provider, Th!nk Inc.)
  "issuer": "did:key:z6Mkj...",

  "issuanceDate": "2026-01-15T10:00:00Z",

  // The subject of the credential: the agent being described
  "credentialSubject": {
    
    // The decentralized identity (DID) of the agent's owner. This is the key.
    "id": "did:key:z6Mkf...",

    "agent": {
      // Agent type to distinguish roles
      "type": "PersonalAgent", // or "BusinessAgent", "ServiceProviderAgent"
      
      // A human-readable name
      "name": "Lena's Personal AI",

      // A list of Layer 1 application protocols this agent supports
      "supportedProtocols": [
        { "protocol": "OACP", "version": "1.0" },
        { "protocol": "OAHP", "version": "1.0" }
      ]
    }
  },

  // The cryptographic proof (signature) of this credential's authenticity
  "proof": {
    "type": "Ed25519Signature2018",
    "created": "2026-01-15T10:00:00Z",
    "verificationMethod": "did:key:z6Mkj...#z6Mkj...",
    "proofPurpose": "assertionMethod",
    "jws": "eyJhbGciOiJFZERTQS..."
  }
}
```

### 2.2 The OAEP Handshake: The Connection Sequence

The handshake is a challenge-response procedure that ensures both parties are the legitimate owners of the private keys associated with their DIDs.

**Flow between Agent A (e.g., Lena's Personal AI) and Agent B (e.g., an Online Shop's Agent):**

1.  **`ConnectionRequest` (Agent A -> Agent B):** Agent A sends its public `AgentProfile` VC to Agent B's known endpoint. This is the initial contact.

2.  **`ConnectionChallenge` (Agent B -> Agent A):** Agent B receives Agent A's VC and validates its signature (`proof`). If valid, Agent B knows the profile comes from a trusted issuer. To prove that Agent B is now talking to the real Agent A (and not an impostor who copied the VC), Agent B generates a random, single-use string (a "Nonce" or "Challenge"). Agent B then sends its own `AgentProfile` VC back to A, along with this challenge.

3.  **`ConnectionResponse` (Agent A -> Agent B):** Agent A receives Agent B's VC and validates its signature. Agent A then signs the received challenge string using its private key, which is associated with its DID (`credentialSubject.id`). Agent A sends this signature back to Agent B.

4.  **Connection Established:** Agent B receives the signature. B now uses the public key from Agent A's `AgentProfile` (which is contained in its DID) to verify the signature against the original challenge it sent.
    *   **If the signature is correct:** B now has cryptographic proof that it is communicating with the legitimate owner of Agent A's private key.
    *   **Result:** A secure, mutually authenticated connection is established. Both agents can now trust each other's DIDs for the duration of the session and proceed with an application protocol (e.g., OACP).

### 2.3 Trust Management: VC Revocation

**Problem:** A Verifiable Credential, once issued, can become invalid (e.g., a driver's license is revoked, a business certificate expires). OAEP must provide a robust, scalable, and privacy-preserving mechanism to check the status of a VC.

**Chosen Standard:** The primary mechanism for VC revocation in the OAP ecosystem is the W3C **`StatusList2021`** standard.

*   **Rationale:** This standard is significantly more efficient and scalable than traditional Revocation Lists. A single `StatusList` can represent the revocation status of thousands of VCs in a compact bit-list, making verification fast and data-efficient.
*   **Future-Readiness:** The architecture remains open for future mechanisms with even stronger privacy guarantees, such as those based on Zero-Knowledge Proofs.

**Protocol Requirements:**

1.  **Mandatory for Issuers:** Any issuer that issues a VC whose status may change **MUST** include a `credentialStatus` property in the VC. This property **MUST** point to a publicly accessible `StatusList2021`.
2.  **Mandatory for Verifiers:** Any agent that validates a VC **MUST**, as part of the validation process, check the `credentialStatus` property, fetch the corresponding `StatusList`, and verify that the credential has not been revoked. Validation without a status check is incomplete and invalid.

**Example of a `credentialStatus` property inside a VC:**
```json
{
  // ... other VC properties like issuer, credentialSubject etc.

  "credentialStatus": {
    "id": "https://example.com/credentials/status/3",
    "type": "StatusList2021",
    "statusListIndex": "42",
    "statusListCredential": "https://example.com/credentials/statuslist/3"
  },
  
  "proof": {
    // ...
  }
}
```

**Conclusion:** By standardizing on `StatusList2021` and making the verification check mandatory, OAEP ensures that trust within the ecosystem is managed dynamically, securely, and reliably. This is a fundamental prerequisite for all higher-level application protocols like OACP and OAHP.

### 2.4 Identity Methods (DID Methods) & Agent Discovery

**Problem:** To ensure interoperability, it must be clearly defined which types of Decentralized Identifiers (DIDs) are supported and how an agent can resolve the network address (the "Service Endpoint") of another agent to establish a connection.

**1. Supported DID Methods**

The OAP framework takes a pragmatic approach and will initially support the following W3C-standardized DID methods:

*   **`did:key`**:
    *   **Description:** A simple method where the DID is derived directly from the public cryptographic key. The DID document is generated algorithmically.
    *   **OAP Use Case:** Ideal for simple peer-to-peer interactions, personal agents of end-users, or ephemeral agents that don't require external anchoring. It offers maximum decentralization and censorship resistance.

*   **`did:web`**:
    *   **Description:** A method that allows a DID to be bound to an existing DNS domain name (e.g., a website). The DID document is hosted at a well-known path on the domain's web server.
    *   **OAP Use Case:** The primary standard for businesses, organizations, and public services. It allows a decentralized identity to be linked with an already established, trustworthy online presence (e.g., `did:web:think-inc.com`).

**Future & Advanced Methods:** The architecture is explicitly open to more methods. For fully decentralized, serverless use cases, the integration of the following method will be strategically considered:

*   **`did:holo`**:
    *   **Description:** An agent-centric DID method based on the DHT (Distributed Hash Table) of the Holochain framework. The DID is directly bound to the cryptographic identity of an agent within a Holochain network.
    *   **OAP Use Case:** The preferred method for implementing OAP agents as Holochain applications ("hApps"). It enables native, censorship-resistant, and serverless addressing and discovery of agents directly on the P2P network.

**2. Mechanism for Agent Discovery**

The discoverability of an agent is ensured via the standardized `service` entry in the agent's DID document.

**Protocol Requirements:**

*   Any agent that wishes to participate and be reachable in the OAP ecosystem **MUST** define at least one `service` entry in its DID document.
*   This entry **MUST** be of type `OAPEndpoint` and contain the publicly reachable HTTPS URL of the agent's endpoint.

**Example of a `service` entry in a `did:web` document:**
```json
{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://openagentprotocol.org/contexts/oaep/v1"
  ],
  "id": "did:web:example-shop.com",
  "verificationMethod": [
    // ... public keys of the agent
  ],
  "service": [
    {
      "id": "did:web:example-shop.com#oap",
      "type": "OAPEndpoint",
      "serviceEndpoint": "https://api.example-shop.com/oap/v1/"
    }
  ]
}
```

### 2.5 Sovereign Key Management

**Problem:** The security and sovereignty of the entire OAP ecosystem depend on the user's ability to securely manage their private cryptographic keys. Key management must fulfill four core requirements: protection from theft, secure usage, planned renewal (rotation), and recoverability in case of device loss.

**1. Guiding Principles**

*   **User Control:** The private key never leaves the user's sphere of control.
*   **Hardware-First:** Whenever possible, keys are managed in hardware-isolated, secure environments (Trusted Execution Environments, Secure Enclaves).

**2. Key Generation and Storage**

OAEP defines two tiers of compliance for key management:

*   **Tier 1: Hardware-backed Storage (Recommended Standard):**
    *   **Mechanism:** Private keys are generated and stored directly inside a **Hardware Security Enclave** (like the "Secure Enclave" on iOS or the "StrongBox Keymaster" on Android). This approach is the core feature of "SovereignOS" and the "Th!nk Phone".
    *   **Security Guarantee:** The private key cannot be physically extracted from the security chip. All cryptographic operations (e.g., signing a transaction) happen inside the enclave.

*   **Tier 2: Software-backed Storage (Fallback Solution):**
    *   **Mechanism:** On systems without an accessible hardware enclave, keys are stored in an encrypted keystore, protected by a strong, user-chosen password or passphrase.
    *   **Note:** This method is necessary to enable the ecosystem on a wide range of devices but offers a lower level of security than hardware-backed storage.

**3. Key Rotation (Planned Renewal)**

To enhance security, users must be able to periodically renew their key pairs. The process is defined as follows:
1.  The user's agent generates a new key pair (Key B).
2.  The agent creates an update operation for the DID document that replaces the old public key (Key A) with the new one (Key B).
3.  This update operation is signed with the old private key (Key A) to prove authorization.
4.  After the update is successfully published, Key B becomes the new authoritative key for the DID.

**4. Key Recovery (Backup & Recovery from Device Loss)**

This is a critical function for mass adoption. OAP will support two user-controlled recovery methods:

*   **Method A: Mnemonic Seed Phrase (Security Passphrase):**
    *   **Description:** Upon identity initialization, the user is shown a 12 or 24-word security passphrase. This phrase is the "master key" from which all private keys can be derived.
    *   **Responsibility:** The user is solely responsible for the secure, offline storage of this phrase. It is the ultimate form of self-sovereignty.

*   **Method B: Social Recovery:**
    *   **Description:** A more user-friendly mechanism that requires no central authority. The user can designate a group of "Guardians". These can be other devices of the user, close friends, or family members who also have an OAP identity.
    *   **Process:** To initiate a recovery, the user (from their new device) sends a recovery request to their guardians. A pre-defined number of guardians (e.g., 3 out of 5) must cryptographically approve this request. Once the quorum is reached, the user can authorize a new master key for their DID.
    *   **Advantage:** No single guardian can steal the identity, and the loss of one or two guardian contacts does not lead to a loss of identity.

**Conclusion:** By combining hardware-backed security with flexible yet sovereign recovery mechanisms, OAEP solves one of the biggest challenges of decentralized systems: the creation of a secure *and* usable key management system.
